# redis数据结构

## 字符串

redis中的字符串主要使用sds结构，并没有直接使用c语言中提供的字符串。

redis中存储数据主要是k-v形式，其中key底层也是使用的sds来实现。已经v中的字符串，底层也是使用sds。

sds结构中，有一个标识空闲空间大小的int型free变量
有一个标识已经使用的空间大小的int型len变量
还有一个存储实际字符的char[]型buf变量。

当buf变量存储的字符串'redis'的时候，len值为5，但是实际上，buf仍然保留了一位来存储空字符。

这样的话，对于buf字符数组，可以直接使用c语言为字符串提供的函数，而不需要基于sds结构再次开发

------------------------
'r'|'e'|'d'|'i'|'s'|'\0'
------------------------
使用sds的话有下面几个好处：

1. 常数时间读取字符已用的空间大小。
  因为c语言中，想要知道内存中存储的字符大小，必须以O(N)的形式去循环查找计数

  而在sds中，只需要读取len就知道了，复杂度从O(N)降低到O(1)

2. 避免缓冲区溢出
   在c中，由于字符串不记录自身长度带来的另外一个问题是容易造成缓冲区溢出（buffer overflow）
   比如strcat函数，用于将一个字符串拼接在另一个字符串的后面。
   如果在内存中，有两个字符串的内存地址紧挨在一起。当执行strcat函数要将另外一个字符串拼接在第一个字符串的后面的时候，可能就会覆盖掉第二个字符串中的值。

   但在redis中，使用sds的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当sds api需要对sds进行修改时，api会先检查sds的空间是否满足修改所需的要求，如果不满足的话，api会自动将sds的空间扩展至执行所需的大小，然后才执行实际操作

3. 减少修改字符串时带来的内存重分配次数
   在c中，修改字符串，比如拼接或者裁切的时候会改变占用的内存，而申请内存分配会涉及到系统调用，（用户态和内核态的切换）
   为了提高性能，尽量减少系统调用。
   redis实现了两种优化策略，一个是空间预分配，另外一个是惰性空间释放。

   